<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Ninja</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #102010;
            font-family: monospace;
            color: #e0f8e0;
            overflow: hidden;
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 0 auto;
        }
        
        canvas {
            border: 4px solid #306630;
            background-color: #8bac8b;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
        }
        
        #instructions {
            max-width: 800px;
            margin: 20px auto;
            padding: 10px;
            text-align: center;
            background-color: #306630;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .key-control {
            margin-right: 10px;
            background-color: #8bac8b;
            padding: 3px 8px;
            border-radius: 3px;
            display: inline-block;
        }
        
        /* Mobile controls */
        #mobile-controls {
            display: none;
            width: 100%;
            max-width: 800px;
            height: 180px;
            position: relative;
            margin-top: 10px;
            touch-action: none;
        }
        
        .control-button {
            position: absolute;
            width: 90px;
            height: 90px;
            background-color: #306630;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #e0f8e0;
            font-weight: bold;
            font-size: 24px;
            user-select: none;
            touch-action: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            border: 2px solid #224422;
        }
        
        #left-button {
            left: 30px;
            top: 45px;
        }
        
        #right-button {
            left: 140px;
            top: 45px;
        }
        
        #jump-button {
            right: 140px;
            top: 45px;
        }
        
        #attack-button {
            right: 30px;
            top: 45px;
        }
        
        /* Media query for mobile devices */
        @media (max-width: 820px) {
            #game-container {
                width: 95%;
                height: auto;
                aspect-ratio: 4/3;
            }
            
            canvas {
                width: 100%;
                height: 100%;
            }
            
            #mobile-controls {
                display: block;
            }
            
            .keyboard-controls {
                display: none;
            }
            
            .mobile-controls-text {
                display: block;
            }
        }
        
        /* For wider screens */
        @media (min-width: 821px) {
            .mobile-controls-text {
                display: none;
            }
        }
    </style>
</head>
<body>
    <h1>SHADOW NINJA</h1>
    
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>
    
    <div id="mobile-controls">
        <div id="left-button" class="control-button">←</div>
        <div id="right-button" class="control-button">→</div>
        <div id="jump-button" class="control-button">Z</div>
        <div id="attack-button" class="control-button">X</div>
    </div>
    
    <div id="instructions">
        <div class="keyboard-controls">
            <span class="key-control">←→</span> Move
            <span class="key-control">Z</span> Jump
            <span class="key-control">X</span> Attack
            <span class="key-control">↑ + WALL</span> Wall Jump
        </div>
        <div class="mobile-controls-text">
            Use the on-screen buttons to play!<br>
            Touch the left/right buttons to move, Z to jump, X to attack.
        </div>
    </div>
    
    <script>
        // Touch controls handling
        document.addEventListener('DOMContentLoaded', function() {
            // Create a global object to track touch controls
            window.touchControls = {
                left: false,
                right: false,
                jump: false,
                attack: false
            };
            
            // Helper function to handle button touches
            function setupTouchButton(id, controlKey) {
                const button = document.getElementById(id);
                
                button.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    touchControls[controlKey] = true;
                    button.style.backgroundColor = '#8bac8b';
                });
                
                button.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    touchControls[controlKey] = false;
                    button.style.backgroundColor = '#306630';
                });
                
                // Prevent default behavior to avoid scrolling
                button.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                });
            }
            
            // Setup all buttons
            setupTouchButton('left-button', 'left');
            setupTouchButton('right-button', 'right');
            setupTouchButton('jump-button', 'jump');
            setupTouchButton('attack-button', 'attack');
            
            // Make the keyboard controls work as virtual key presses
            window.addEventListener('keydown', function(e) {
                switch(e.key) {
                    case 'ArrowLeft': 
                        keys.ArrowLeft = true;
                        break;
                    case 'ArrowRight': 
                        keys.ArrowRight = true;
                        break;
                    case 'z':
                    case 'Z': 
                        keys.z = true;
                        break;
                    case 'x':
                    case 'X': 
                        keys.x = true;
                        break;
                    case ' ': 
                        keys[' '] = true;
                        break;
                }
            });
            
            window.addEventListener('keyup', function(e) {
                switch(e.key) {
                    case 'ArrowLeft': 
                        keys.ArrowLeft = false;
                        break;
                    case 'ArrowRight': 
                        keys.ArrowRight = false;
                        break;
                    case 'z':
                    case 'Z': 
                        keys.z = false;
                        break;
                    case 'x':
                    case 'X': 
                        keys.x = false;
                        break;
                    case ' ': 
                        keys[' '] = false;
                        break;
                }
            });
            
            // Handle touch controls in game loop
            const gameLoop = function() {
                // Map touch controls to key presses
                if (window.keys) {
                    keys.ArrowLeft = keys.ArrowLeft || touchControls.left;
                    keys.ArrowRight = keys.ArrowRight || touchControls.right;
                    keys.z = keys.z || touchControls.jump;
                    keys.x = keys.x || touchControls.attack;
                }
                
                requestAnimationFrame(gameLoop);
            };
            
            gameLoop();
        });
    </script>
    
    <script>
        // Define colors based on GameBoy palette
        const COLORS = {
            black: '#0f0f0f',
            darkGray: '#306630',
            lightGray: '#8bac8b',
            white: '#e0f8e0',
            bg: '#8bac8b'
        };

        // Constants
        const GRAVITY = 800;
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;

        // Game state variables
        let gameState = 'start_screen';
        let stage = 1;
        let canvas, ctx;
        let player, platforms, enemies, projectiles, particles;
        let lastTime = 0;
        let keys = {};

        // Visual effects variables
        let screenFlash = {active: false, duration: 0, intensity: 0};
        let lightning = {active: false, timer: 0, nextStrike: Math.random() * 5 + 3, bolts: []};

        // Initialize when the window loads
        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Initialize keys
            window.keys = keys = {};
            
            // Set up event listeners for keyboard
            window.addEventListener('keydown', function(e) {
                keys[e.key] = true;
            });
            
            window.addEventListener('keyup', function(e) {
                keys[e.key] = false;
            });
            
            // Initialize game objects
            resetGame();
            
            // Start game loop
            lastTime = performance.now();
            requestAnimationFrame(update);
        };

        // Basic game loop
        function update() {
            // Request next frame
            requestAnimationFrame(update);
            
            // Get time since last frame
            const now = performance.now();
            const dt = (now - lastTime) / 1000; // Convert to seconds
            lastTime = now;
            
            // Process input
            if (gameState === 'start_screen' && (keys[' '] || keys.Space)) {
                gameState = 'playing';
            }
            
            // Clear canvas
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update visual effects
            updateVisualEffects(dt);
            
            // Draw based on game state
            if (gameState === 'start_screen') {
                drawStartScreen();
            } else if (gameState === 'playing') {
                // Handle inputs
                handleInput(dt);
                
                // Update physics
                updatePhysics(dt);
                
                // Update player state
                updatePlayerState(dt);
                
                // Update enemies
                updateEnemies(dt);
                
                // Check collisions
                checkCollisions();
                
                // Draw background
                drawBackground();
                
                // Draw platforms
                platforms.forEach(platform => {
                    drawPlatform(platform);
                });
                
                // Draw enemies
                enemies.forEach(enemy => {
                    drawEnemy(enemy);
                });
                
                // Draw projectiles
                projectiles.forEach(projectile => {
                    drawProjectile(projectile);
                });
                
                // Draw player
                drawPlayer();
                
                // Draw particles
                particles.forEach(particle => {
                    drawParticle(particle);
                });
                
                // Draw UI elements
                drawUI();
                
                // Final boss position verification - ultimate failsafe
                for (const enemy of enemies) {
                    if (enemy.type === 'boss') {
                        // If boss is off-screen after all other processing, force it back
                        if (enemy.x < 0 || enemy.y < 0 || 
                            enemy.x > canvas.width || enemy.y > canvas.height) {
                            
                            console.log("EMERGENCY: Boss recovery initiated in main game loop!");
                            enemy.x = canvas.width / 2 - enemy.width / 2;
                            enemy.y = canvas.height / 2;
                            enemy.dy = 0;
                            enemy.dx = 0;
                            
                            // Create a visual indicator for this emergency reset
                            for (let i = 0; i < 30; i++) {
                                particles.push({
                                    x: enemy.x + enemy.width/2,
                                    y: enemy.y + enemy.height/2,
                                    dx: (Math.random() - 0.5) * 100,
                                    dy: (Math.random() - 0.5) * 100,
                                    size: 4 + Math.random() * 5,
                                    color: COLORS.white,
                                    lifetime: 0,
                                    maxLifetime: 1.0
                                });
                            }
                        }
                    }
                }
                
                // Check for level completion (updated to handle both Stage 1 and Stage 2)
                if ((stage === 1 || stage === 2) && player.x > canvas.width - 50 && enemies.length === 0) {
                    stage++;
                    loadStage(stage);
                }
                
                // Check for player death
                if (player.health <= 0) {
                    gameState = 'game_over';
                }
            } else if (gameState === 'game_over') {
                drawGameOverScreen();
            } else if (gameState === 'game_complete') {
                drawGameCompleteScreen();
            }
        }

        // Function to update visual effects
        function updateVisualEffects(dt) {
            // Update screen flash effect (thunder)
            if (screenFlash.active) {
                screenFlash.duration -= dt;
                
                // Create fading effect
                if (screenFlash.duration > 0.1) {
                    screenFlash.intensity = Math.min(0.7, screenFlash.duration);
                } else {
                    screenFlash.intensity *= 0.8;
                }
                
                // Deactivate when done
                if (screenFlash.duration <= 0 || screenFlash.intensity < 0.05) {
                    screenFlash.active = false;
                }
            }
            
            // Update lightning effect
            lightning.timer += dt;
            
            // Check if it's time for a lightning strike
            if (lightning.timer >= lightning.nextStrike) {
                // Create new lightning bolts
                createLightning();
                
                // Reset timer and set time for next strike (random interval)
                lightning.timer = 0;
                lightning.nextStrike = Math.random() * 8 + 4; // 4-12 seconds between strikes
                
                // Activate lightning
                lightning.active = true;
                
                // Create thunder flash effect with slight delay
                setTimeout(() => {
                    screenFlash.active = true;
                    screenFlash.duration = 0.2;
                    screenFlash.intensity = 0.3;
                }, Math.random() * 300 + 100); // 100-400ms delay
            }
            
            // Deactivate lightning after short duration
            if (lightning.active && lightning.timer > 0.2) {
                lightning.active = false;
                lightning.bolts = [];
            }
        }

        // Function to create lightning
        function createLightning() {
            // Clear existing bolts
            lightning.bolts = [];
            
            // Create 1-3 lightning bolts
            const numBolts = Math.floor(Math.random() * 3) + 1;
            
            for (let i = 0; i < numBolts; i++) {
                // Random starting position along the top of the screen
                const startX = Math.random() * GAME_WIDTH;
                
                lightning.bolts.push({
                    startX: startX,
                    startY: 0,
                    endY: GAME_HEIGHT * (0.3 + Math.random() * 0.5), // Random height
                    width: 1 + Math.random() * 3,
                    segmentLength: 10 + Math.random() * 20,
                    jitter: 30 + Math.random() * 50
                });
            }
        }

        // Function to draw the start screen
        function drawStartScreen() {
            // Title screen
            // Background
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title text with shadow
            ctx.fillStyle = COLORS.black;
            ctx.font = '46px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('SHADOW NINJA', canvas.width/2 + 3, canvas.height/3 + 3);
            
            ctx.fillStyle = COLORS.white;
            ctx.fillText('SHADOW NINJA', canvas.width/2, canvas.height/3);
            
            // Instructions
            ctx.font = '18px monospace';
            ctx.fillStyle = COLORS.white;
            ctx.textAlign = 'center';
            
            // Controls info
            const instructions = [
                'CONTROLS:',
                'Arrow Keys: Move',
                'Z: Jump',
                'X: Attack',
                'Press SPACE to Start'
            ];
            
            for (let i = 0; i < instructions.length; i++) {
                ctx.fillText(instructions[i], canvas.width/2, canvas.height/2 + i * 30);
            }
            
            // Blinking Press Start text
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.font = '24px monospace';
                ctx.fillText('PRESS SPACE TO START', canvas.width/2, canvas.height - 60);
            }
        }
        
        // Function to reset the game state for a new game
        function resetGame() {
            // Create player
            player = {
                x: 50,
                y: 200,
                width: 30,
                height: 50,
                dx: 0,
                dy: 0,
                speed: 200,
                jumpStrength: 400,
                health: 6,
                maxHealth: 6,
                score: 0,
                state: 'idle',
                facing: 1,
                canJump: true,
                attacking: false,
                attackTimer: 0,
                invulnerable: 0,
                wallSliding: false,
                wallCling: false,
                wallDirection: 0,
                wallJumps: 0, // Track consecutive wall jumps
                maxWallJumps: 5, // Maximum consecutive wall jumps allowed
                wallJumpCooldown: 0, // Cooldown between wall jumps
                currentCorner: null
            };
            
            // Initialize collections
            platforms = [];
            enemies = [];
            projectiles = [];
            particles = [];
            
            // Set up the stage
            stage = 1;
            loadStage(stage);
        }
        
        // Load a specific stage
        function loadStage(stageNum) {
            // Clear existing entities
            platforms = [];
            enemies = [];
            projectiles = [];
            particles = [];
            
            // Set up platforms
            switch(stageNum) {
                case 1:
                    // Stage 1: Basic level with some platforms
                    
                    // Ground
                    platforms.push({
                        x: 0,
                        y: GAME_HEIGHT - 40,
                        width: GAME_WIDTH,
                        height: 40,
                        type: 'normal'
                    });
                    
                    // Platforms
                    platforms.push({
                        x: 100,
                        y: GAME_HEIGHT - 120,
                        width: 200,
                        height: 20,
                        type: 'normal'
                    });
                    
                    platforms.push({
                        x: 400,
                        y: GAME_HEIGHT - 180,
                        width: 200,
                        height: 20,
                        type: 'normal'
                    });
                    
                    platforms.push({
                        x: 650,
                        y: GAME_HEIGHT - 150,
                        width: 150,
                        height: 20,
                        type: 'normal'
                    });
                    
                    // Walls for wall jumping
                    platforms.push({
                        x: 300,
                        y: GAME_HEIGHT - 220,
                        width: 20,
                        height: 100,
                        type: 'normal'
                    });
                    
                    platforms.push({
                        x: 600,
                        y: GAME_HEIGHT - 220,
                        width: 20,
                        height: 100,
                        type: 'normal'
                    });
                    
                    // Add enemies
                    
                    // Patrol enemy on first platform
                    enemies.push({
                        x: 150,
                        y: GAME_HEIGHT - 160,
                        width: 30,
                        height: 40,
                        type: 'patrol',
                        health: 1,
                        speed: 60,
                        direction: 1,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    // Flying enemy above
                    enemies.push({
                        x: 350,
                        y: GAME_HEIGHT - 250,
                        width: 25,
                        height: 25,
                        type: 'flyer',
                        health: 1,
                        speed: 80,
                        direction: 1,
                        yOffset: 0,
                        amplitude: 30,
                        frequency: 3,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    // Projectile thrower on middle platform
                    enemies.push({
                        x: 500,
                        y: GAME_HEIGHT - 220,
                        width: 30,
                        height: 40,
                        type: 'thrower',
                        health: 1,
                        attackCooldown: 0,
                        attackInterval: 2,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    // Jumping enemy
                    enemies.push({
                        x: 700,
                        y: GAME_HEIGHT - 190,
                        width: 25,
                        height: 30,
                        type: 'jumper',
                        health: 1,
                        speed: 40,
                        jumpPower: 350,
                        direction: -1,
                        jumpCooldown: 0,
                        jumpInterval: 1.5,
                        dy: 0,
                        onGround: true,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    break;
                    
                case 2:
                    // Stage 2: Boss battle stage
                    
                    // Ground
                    platforms.push({
                        x: 0,
                        y: GAME_HEIGHT - 40,
                        width: GAME_WIDTH,
                        height: 40,
                        type: 'normal'
                    });
                    
                    // Side platforms for player to avoid boss attacks
                    platforms.push({
                        x: 50,
                        y: GAME_HEIGHT - 150,
                        width: 150,
                        height: 20,
                        type: 'normal'
                    });
                    
                    platforms.push({
                        x: 500,
                        y: GAME_HEIGHT - 150,
                        width: 150,
                        height: 20,
                        type: 'normal'
                    });
                    
                    // Adding stage 2 enemies (NOT the boss - boss should only be in stage 3)
                    // Tougher patrol enemies
                    enemies.push({
                        x: 150,
                        y: GAME_HEIGHT - 80,
                        width: 30,
                        height: 40,
                        type: 'patrol',
                        health: 2,
                        speed: 80,
                        direction: 1,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    enemies.push({
                        x: 450,
                        y: GAME_HEIGHT - 80,
                        width: 30,
                        height: 40,
                        type: 'patrol',
                        health: 2,
                        speed: 80,
                        direction: -1,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    // Advanced thrower enemy
                    enemies.push({
                        x: GAME_WIDTH/2,
                        y: GAME_HEIGHT - 80,
                        width: 30,
                        height: 40,
                        type: 'thrower',
                        health: 2,
                        attackCooldown: 0,
                        attackInterval: 1.5,
                        animFrame: 0,
                        animTimer: 0
                    });
                    
                    break;
                    
                case 3:
                    // Stage 3: Final Boss battle
                    
                    // Ground
                    platforms.push({
                        x: 0,
                        y: GAME_HEIGHT - 40,
                        width: GAME_WIDTH,
                        height: 40,
                        type: 'normal'
                    });
                    
                    // Side platforms for player to avoid boss attacks
                    platforms.push({
                        x: 50,
                        y: GAME_HEIGHT - 150,
                        width: 150,
                        height: 20,
                        type: 'normal'
                    });
                    
                    platforms.push({
                        x: 500,
                        y: GAME_HEIGHT - 150,
                        width: 150,
                        height: 20,
                        type: 'normal'
                    });
                    
                    // Boss enemy
                    enemies.push({
                        x: GAME_WIDTH/2 - 40,
                        y: GAME_HEIGHT - 160,
                        width: 80,
                        height: 120,
                        type: 'boss',
                        health: 10,
                        maxHealth: 10,
                        speed: 70,
                        direction: 1,
                        attackCooldown: 3,
                        attackPhase: 0, // 0-ground attack, 1-jump attack, 2-projectile barrage
                        phaseTimer: 4,
                        jumpPower: 500,
                        dy: 0,
                        onGround: true,
                        isInvulnerable: false,
                        invulnerableTimer: 0,
                        animFrame: 0,
                        animTimer: 0,
                        flashTimer: 0,
                        currentCorner: null
                    });
                    
                    console.log("Boss initialized with health:", enemies[enemies.length-1].health);
                    
                    break;
            }
            
            // Reset player position
            player.x = 50;
            player.y = GAME_HEIGHT - 200;
            player.health = player.maxHealth;
        }
        
        // Handle user input
        function handleInput(dt) {
            // Reset speed first
            player.dx = 0;
            
            // Left/Right movement
            if (keys.ArrowLeft) {
                player.dx = -player.speed;
                player.facing = -1;
                player.state = player.canJump ? 'run' : player.state;
            } else if (keys.ArrowRight) {
                player.dx = player.speed;
                player.facing = 1;
                player.state = player.canJump ? 'run' : player.state;
            } else if (player.canJump) {
                player.state = 'idle';
            }
            
            // Wall Jump cooldown
            if (player.wallJumpCooldown > 0) {
                player.wallJumpCooldown -= dt;
            }
            
            // Jump
            if ((keys.ArrowUp || keys.z)) {
                if (player.canJump) {
                    // Regular jump
                    player.dy = -player.jumpStrength;
                    player.canJump = false;
                    player.state = 'jump';
                } else if (player.wallCling && player.wallJumpCooldown <= 0 && player.wallJumps < player.maxWallJumps) {
                    // Wall jump - push away from wall and upward
                    player.dy = -player.jumpStrength * 0.9;
                    player.dx = player.wallDirection * player.speed * 1.1;
                    player.wallCling = false;
                    player.wallSliding = false;
                    player.state = 'jump';
                    player.wallJumps++;
                    player.wallJumpCooldown = 0.15; // Short cooldown between wall jumps
                    
                    // Create wall jump effect
                    for (let i = 0; i < 5; i++) {
                        particles.push({
                            x: player.x + (player.wallDirection < 0 ? player.width : 0),
                            y: player.y + player.height/2 + (Math.random() - 0.5) * 20,
                            dx: player.wallDirection * (20 + Math.random() * 20),
                            dy: (Math.random() - 0.5) * 40,
                            size: 2 + Math.random() * 3,
                            color: COLORS.white,
                            lifetime: 0,
                            maxLifetime: 0.3
                        });
                    }
                }
            }
            
            // Attack
            if (keys.x && !player.attacking) {
                player.attacking = true;
                player.attackTimer = 0;
                
                // Create shuriken projectile
                projectiles.push({
                    x: player.x + (player.facing > 0 ? player.width : 0),
                    y: player.y + player.height/2 - 5,
                    width: 10,
                    height: 10,
                    dx: player.facing * 300,
                    dy: 0,
                    damage: 1,
                    lifetime: 0,
                    type: 'shuriken',
                    fromPlayer: true
                });
            }
        }
        
        // Helper function to update physics
        function updatePhysics(dt) {
            // Store previous position for collision calculations
            const prevX = player.x;
            const prevY = player.y;
            
            // Apply gravity to player
            player.dy += GRAVITY * dt;
            
            // Limit maximum falling speed to prevent tunneling through platforms
            const maxFallSpeed = 800;
            if (player.dy > maxFallSpeed) player.dy = maxFallSpeed;
            
            // Move player horizontally first
            player.x += player.dx * dt;
            
            // Reset wall jumping logic
            player.wallSliding = false;
            player.wallCling = false;
            
            // Handle horizontal collisions first
            let horizontalCollision = false;
            for (let platform of platforms) {
                if (player.x + player.width > platform.x &&
                    player.x < platform.x + platform.width &&
                    player.y + player.height > platform.y + 5 && // Small buffer to prioritize horizontal collisions
                    player.y < platform.y + platform.height - 5) {
                    
                    // Coming from left (hitting right edge of platform)
                    if (prevX + player.width <= platform.x + 2) {
                        player.x = platform.x - player.width;
                        player.dx = 0;
                        horizontalCollision = true;
                        
                        // Wall sliding and clinging
                        if (!player.canJump && player.dy > 0) {
                            player.wallSliding = true;
                            player.wallCling = true;
                            player.wallDirection = 1; // Right wall
                            player.dy = Math.min(player.dy, 80); // Slow fall when wall sliding
                        }
                    }
                    // Coming from right (hitting left edge of platform)
                    else if (prevX >= platform.x + platform.width - 2) {
                        player.x = platform.x + platform.width;
                        player.dx = 0;
                        horizontalCollision = true;
                        
                        // Wall sliding and clinging
                        if (!player.canJump && player.dy > 0) {
                            player.wallSliding = true;
                            player.wallCling = true;
                            player.wallDirection = -1; // Left wall
                            player.dy = Math.min(player.dy, 80); // Slow fall when wall sliding
                        }
                    }
                }
            }
            
            // Now move player vertically
            player.y += player.dy * dt;
            
            // Handle vertical collisions
            let verticalCollision = false;
            for (let platform of platforms) {
                if (player.x + player.width > platform.x + 2 &&
                    player.x < platform.x + platform.width - 2 &&
                    player.y + player.height > platform.y &&
                    player.y < platform.y + platform.height) {
                    
                    // Coming from above (landing)
                    if (prevY + player.height <= platform.y + 5) {
                        player.y = platform.y - player.height;
                        player.dy = 0;
                        player.canJump = true;
                        player.wallJumps = 0; // Reset wall jumps when landing
                        verticalCollision = true;
                    }
                    // Coming from below (hitting ceiling)
                    else if (prevY >= platform.y + platform.height - 5 && !verticalCollision) {
                        player.y = platform.y + platform.height;
                        player.dy = 0;
                        verticalCollision = true;
                    }
                }
            }
            
            // Special case for vertical walls in stage 1
            // If player is against a thin vertical wall, ensure they don't get stuck inside it
            for (let platform of platforms) {
                // Check if this is a vertical wall-like platform (much taller than wide)
                if (platform.height > platform.width * 2) {
                    const isNearLeftEdge = Math.abs(player.x + player.width - platform.x) < 5;
                    const isNearRightEdge = Math.abs(player.x - (platform.x + platform.width)) < 5;
                    
                    if ((isNearLeftEdge || isNearRightEdge) && 
                        player.y + player.height > platform.y &&
                        player.y < platform.y + platform.height) {
                        
                        // If player is inside the wall, push them out
                        if (player.x + player.width > platform.x + 2 && 
                            player.x < platform.x + platform.width - 2) {
                            
                            // Find which side is closer and push that way
                            const distToLeft = player.x + player.width - platform.x;
                            const distToRight = platform.x + platform.width - player.x;
                            
                            if (distToLeft < distToRight) {
                                player.x = platform.x - player.width;
                            } else {
                                player.x = platform.x + platform.width;
                            }
                            
                            player.dx = 0;
                        }
                    }
                }
            }
            
            // Screen boundaries
            if (player.x < 0) {
                player.x = 0;
                // Allow wall climbing on screen edges too
                if (!player.canJump && player.dy > 0) {
                    player.wallSliding = true;
                    player.wallCling = true;
                    player.wallDirection = 1; // Right wall (pushing left)
                    player.dy = Math.min(player.dy, 80); // Slow fall when wall sliding
                }
            }
            if (player.x + player.width > canvas.width) {
                player.x = canvas.width - player.width;
                // Allow wall climbing on screen edges too
                if (!player.canJump && player.dy > 0) {
                    player.wallSliding = true;
                    player.wallCling = true;
                    player.wallDirection = -1; // Left wall (pushing right)
                    player.dy = Math.min(player.dy, 80); // Slow fall when wall sliding
                }
            }
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) {
                player.y = canvas.height - player.height;
                player.dy = 0;
                player.canJump = true;
                player.wallJumps = 0; // Reset wall jumps when landing
            }
            
            // Final failsafe - if player somehow gets stuck inside a platform, try to resolve it
            for (let platform of platforms) {
                if (player.x + player.width > platform.x + 5 &&
                    player.x < platform.x + platform.width - 5 &&
                    player.y + player.height > platform.y + 5 &&
                    player.y < platform.y + platform.height - 5) {
                    
                    // Player is inside platform - find nearest edge to eject them
                    const distToTop = player.y + player.height - platform.y;
                    const distToBottom = platform.y + platform.height - player.y;
                    const distToLeft = player.x + player.width - platform.x;
                    const distToRight = platform.x + platform.width - player.x;
                    
                    // Find the smallest distance to an edge
                    const minDist = Math.min(distToTop, distToBottom, distToLeft, distToRight);
                    
                    if (minDist === distToTop) {
                        player.y = platform.y - player.height;
                        player.dy = 0;
                        player.canJump = true;
                    } else if (minDist === distToBottom) {
                        player.y = platform.y + platform.height;
                        player.dy = 0;
                    } else if (minDist === distToLeft) {
                        player.x = platform.x - player.width;
                        player.dx = 0;
                    } else if (minDist === distToRight) {
                        player.x = platform.x + platform.width;
                        player.dx = 0;
                    }
                }
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                // Update position
                proj.x += proj.dx * dt;
                proj.y += proj.dy * dt;
                
                // Update lifetime
                proj.lifetime += dt;
                
                // Remove if off screen or too old
                if (proj.x < -50 || proj.x > canvas.width + 50 || 
                    proj.y < -50 || proj.y > canvas.height + 50 ||
                    proj.lifetime > 3) {
                    projectiles.splice(i, 1);
                }
            }
        }
        
        // Helper function to update player state
        function updatePlayerState(dt) {
            // Handle invulnerability timer
            if (player.invulnerable > 0) {
                player.invulnerable -= dt;
            }
            
            // Handle attack timer
            if (player.attacking) {
                player.attackTimer += dt;
                if (player.attackTimer > 0.3) { // Attack duration
                    player.attacking = false;
                    player.attackTimer = 0;
                }
            }
            
            // Check if player is falling
            if (player.dy > 0 && !player.canJump) {
                player.state = 'jump';
            }
        }
        
        // Function to draw a platform
        function drawPlatform(platform) {
            ctx.fillStyle = COLORS.darkGray;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            
            // Add highlights
            ctx.fillStyle = COLORS.lightGray;
            ctx.fillRect(platform.x, platform.y, platform.width, 5);
        }
        
        // Function to draw background elements
        function drawBackground() {
            // Draw sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
            gradient.addColorStop(0, COLORS.bg);
            gradient.addColorStop(1, COLORS.darkGray);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            // Draw cityscape silhouette
            ctx.fillStyle = COLORS.black;
            
            // Draw buildings
            for (let i = 0; i < 10; i++) {
                const buildingWidth = 60 + (i * 20) % 40;
                const buildingHeight = 100 + (i * 30) % 120;
                const x = i * 100 - 20;
                
                // Building silhouette
                ctx.fillRect(x, GAME_HEIGHT - buildingHeight, buildingWidth, buildingHeight);
                
                // Windows (lit up)
                ctx.fillStyle = COLORS.white;
                const windowSize = 5;
                const windowSpacing = 15;
                
                for (let wy = 0; wy < Math.floor(buildingHeight / windowSpacing) - 1; wy++) {
                    for (let wx = 0; wx < Math.floor(buildingWidth / windowSpacing); wx++) {
                        // Only draw some windows (random pattern but consistent)
                        if ((wx + wy + i) % 3 !== 0) {
                            ctx.fillRect(
                                x + wx * windowSpacing + 5,
                                GAME_HEIGHT - buildingHeight + wy * windowSpacing + 15,
                                windowSize,
                                windowSize
                            );
                        }
                    }
                }
                
                ctx.fillStyle = COLORS.black;
            }
            
            // Draw moon
            ctx.fillStyle = COLORS.white;
            ctx.beginPath();
            ctx.arc(100, 80, 40, 0, Math.PI * 2);
            ctx.fill();
            
            // Moon craters
            ctx.fillStyle = COLORS.lightGray;
            ctx.beginPath();
            ctx.arc(110, 70, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(80, 90, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lightning bolts if active
            if (lightning.active && lightning.bolts.length > 0) {
                for (const bolt of lightning.bolts) {
                    drawLightningBolt(bolt);
                }
            }
            
            // Apply screen flash effect if active (thunder effect)
            if (screenFlash.active) {
                ctx.globalAlpha = screenFlash.intensity;
                ctx.fillStyle = COLORS.black;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }
        }
        
        // Function to create and draw a lightning bolt
        function drawLightningBolt(bolt) {
            ctx.strokeStyle = COLORS.white;
            ctx.lineWidth = bolt.width;
            
            ctx.beginPath();
            ctx.moveTo(bolt.startX, bolt.startY);
            
            let currentX = bolt.startX;
            let currentY = bolt.startY;
            
            // Create zig-zag pattern for lightning
            while (currentY < bolt.endY) {
                const nextY = currentY + bolt.segmentLength;
                const nextX = currentX + (Math.random() - 0.5) * bolt.jitter;
                
                ctx.lineTo(nextX, nextY);
                
                currentX = nextX;
                currentY = nextY;
            }
            
            ctx.stroke();
            
            // Draw a glow around the lightning for effect
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = COLORS.lightGray;
            ctx.lineWidth = bolt.width * 3;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            ctx.lineWidth = 1;
        }
        
        // Function to draw the player
        function drawPlayer() {
            // Draw with slight transparency if invulnerable
            if (player.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }
            
            // Calculate animation offsets based on movement
            const runCycle = player.dx !== 0 && player.canJump ? Math.floor(Date.now() / 100) % 4 : 0;
            const legOffset = [0, 2, 0, -2][runCycle];
            
            // Save the current context state
            ctx.save();
            
            // Draw shadow beneath player (not affected by rotation)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(
                player.x + player.width/2, 
                player.y + player.height - 2,
                player.width/2,
                4,
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Determine if rolling (in the air and not wall clinging)
            const isRolling = !player.canJump && !player.wallCling;
            
            if (isRolling) {
                // Calculate rotation based on vertical velocity and horizontal direction
                const jumpHeight = 400;
                const jumpProgress = Math.abs(player.dy) / jumpHeight;
                const rotationAngle = jumpProgress * Math.PI * 2 * (player.dy > 0 ? 1 : -1) * player.facing;
                
                // Center of rotation is the middle of the player sprite
                const centerX = player.x + player.width/2;
                const centerY = player.y + player.height/2;
                
                // Translate to center, rotate, then translate back
                ctx.translate(centerX, centerY);
                ctx.rotate(rotationAngle);
                
                // Draw ball shape instead of regular ninja pose
                // Black circular body
                ctx.fillStyle = COLORS.black;
                ctx.beginPath();
                ctx.arc(0, 0, player.width/2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // White headband/mask detail (stripe across the ball)
                ctx.fillStyle = COLORS.white;
                ctx.fillRect(-player.width/3, -player.height/12, player.width*2/3, player.height/6);
                
                // Add spinning motion lines 
                const spinLines = 8;
                ctx.strokeStyle = COLORS.white;
                ctx.lineWidth = 1;
                
                for (let i = 0; i < spinLines; i++) {
                    const angle = (i / spinLines) * Math.PI * 2;
                    const innerRadius = player.width/2.5 + 2;
                    const outerRadius = player.width/2.5 + 8 + Math.sin(Date.now() * 0.01 + i) * 3;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        Math.cos(angle) * innerRadius,
                        Math.sin(angle) * innerRadius
                    );
                    ctx.lineTo(
                        Math.cos(angle) * outerRadius,
                        Math.sin(angle) * outerRadius
                    );
                    ctx.stroke();
                }
                
                // Add trail particles when spinning
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = player.width/2.5 + 2;
                    
                    particles.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius,
                        dx: Math.cos(angle) * 20 * (Math.random() + 0.5),
                        dy: Math.sin(angle) * 20 * (Math.random() + 0.5),
                        size: 2 + Math.random() * 2,
                        color: COLORS.white,
                        lifetime: 0,
                        maxLifetime: 0.3
                    });
                }
                
                // Restore context after ball drawing
                ctx.restore();
            } else {
                // Regular ninja drawing (not rolling)
                // Ninja body - slightly hunched over posture
                ctx.fillStyle = COLORS.black;
                ctx.fillRect(
                    player.x + player.width/6, 
                    player.y + player.height/8, 
                    player.width*2/3, 
                    player.height*7/8
                );
                
                // Legs with animation
                ctx.fillStyle = COLORS.black;
                
                // Left leg
                ctx.fillRect(
                    player.x + player.width/3 - 2,
                    player.y + player.height*2/3,
                    player.width/8,
                    player.height/3 + legOffset
                );
                
                // Right leg
                ctx.fillRect(
                    player.x + player.width*2/3 - 2,
                    player.y + player.height*2/3,
                    player.width/8,
                    player.height/3 - legOffset
                );
                
                // Ninja head wrapping (full face mask)
                ctx.fillStyle = COLORS.black;
                ctx.fillRect(
                    player.x + player.width/6, 
                    player.y, 
                    player.width*2/3, 
                    player.height/4
                );
                
                // Eye slit - narrow white band
                ctx.fillStyle = COLORS.white;
                ctx.fillRect(
                    player.x + player.width/4,
                    player.y + player.height/10,
                    player.width/2,
                    player.height/20
                );
                
                // Add ninja equipment - belt
                ctx.fillStyle = COLORS.darkGray;
                ctx.fillRect(
                    player.x + player.width/6,
                    player.y + player.height/2 - player.height/16,
                    player.width*2/3,
                    player.height/8
                );
                
                // Sash/rope knot on belt
                ctx.fillStyle = COLORS.white;
                ctx.fillRect(
                    player.x + player.width/2 - player.width/16,
                    player.y + player.height/2 - player.height/16,
                    player.width/8,
                    player.height/8
                );
                
                // Arm holding shuriken when attacking
                if (player.attacking) {
                    ctx.fillStyle = COLORS.black;
                    if (player.facing > 0) {
                        // Right arm extended
                        ctx.fillRect(
                            player.x + player.width*2/3,
                            player.y + player.height/3,
                            player.width/2,
                            player.width/8
                        );
                        
                        // Small shuriken in hand
                        const hand_x = player.x + player.width*2/3 + player.width/2 - player.width/16;
                        const hand_y = player.y + player.height/3 + player.width/16;
                        
                        ctx.fillStyle = COLORS.white;
                        ctx.beginPath();
                        ctx.moveTo(hand_x, hand_y - player.width/20);
                        ctx.lineTo(hand_x + player.width/20, hand_y);
                        ctx.lineTo(hand_x, hand_y + player.width/20);
                        ctx.lineTo(hand_x - player.width/20, hand_y);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Left arm extended
                        ctx.fillRect(
                            player.x - player.width/2 + player.width/3,
                            player.y + player.height/3,
                            player.width/2,
                            player.width/8
                        );
                        
                        // Small shuriken in hand
                        const hand_x = player.x - player.width/2 + player.width/3 + player.width/16;
                        const hand_y = player.y + player.height/3 + player.width/16;
                        
                        ctx.fillStyle = COLORS.white;
                        ctx.beginPath();
                        ctx.moveTo(hand_x, hand_y - player.width/20);
                        ctx.lineTo(hand_x + player.width/20, hand_y);
                        ctx.lineTo(hand_x, hand_y + player.width/20);
                        ctx.lineTo(hand_x - player.width/20, hand_y);
                        ctx.closePath();
                        ctx.fill();
                    }
                } else {
                    // Normal arm position
                    ctx.fillStyle = COLORS.black;
                    if (player.facing > 0) {
                        // Right arm
                        ctx.fillRect(
                            player.x + player.width*2/3,
                            player.y + player.height/3,
                            player.width/6,
                            player.height/3
                        );
                    } else {
                        // Left arm
                        ctx.fillRect(
                            player.x + player.width/6,
                            player.y + player.height/3,
                            player.width/6,
                            player.height/3
                        );
                    }
                }
                
                // Draw scarf - longer and more flowing
                ctx.fillStyle = COLORS.white;
                
                // Scarf behavior depends on movement state
                let scarfWave = Math.sin(Date.now() * 0.01) * 3;
                let scarfLength = 15;
                
                if (player.dx !== 0) {
                    // Running scarf - flows behind more dramatically
                    scarfLength = 20;
                    scarfWave = Math.sin(Date.now() * 0.015) * 6;
                } else if (player.wallCling) {
                    // Wall climbing scarf - points downward
                    scarfLength = 15;
                    scarfWave = Math.sin(Date.now() * 0.008) * 4;
                }
                
                ctx.beginPath();
                ctx.moveTo(
                    player.x + (player.facing > 0 ? player.width/4 : player.width*3/4),
                    player.y + player.height/5
                );
                
                // Different scarf animation based on wall climbing
                if (player.wallCling) {
                    // When wall climbing, scarf points more downward
                    ctx.lineTo(
                        player.x + (player.facing > 0 ? -scarfLength : player.width + scarfLength),
                        player.y + player.height/3 + scarfWave
                    );
                    ctx.lineTo(
                        player.x + (player.facing > 0 ? -scarfLength/2 : player.width + scarfLength/2),
                        player.y + player.height/2 + scarfWave*1.5
                    );
                    ctx.lineTo(
                        player.x + (player.facing > 0 ? player.width/6 : player.width*5/6),
                        player.y + player.height/3
                    );
                } else {
                    // Normal scarf animation
                    ctx.lineTo(
                        player.x + (player.facing > 0 ? -scarfLength : player.width + scarfLength),
                        player.y + player.height/4 + scarfWave
                    );
                    ctx.lineTo(
                        player.x + (player.facing > 0 ? -scarfLength/1.5 : player.width + scarfLength/1.5),
                        player.y + player.height/2 + scarfWave*1.2
                    );
                    ctx.lineTo(
                        player.x + (player.facing > 0 ? player.width/6 : player.width*5/6),
                        player.y + player.height/3
                    );
                }
                ctx.fill();
                
                // Draw wall climbing pose
                if (player.wallCling) {
                    // Arm reaching to wall
                    ctx.fillStyle = COLORS.black;
                    
                    if (player.wallDirection > 0) { // Right wall
                        ctx.fillRect(
                            player.x + player.width - player.width/10,
                            player.y + player.height/3,
                            player.width/10,
                            player.height/4
                        );
                    } else { // Left wall
                        ctx.fillRect(
                            player.x,
                            player.y + player.height/3,
                            player.width/10,
                            player.height/4
                        );
                    }
                }
                
                // Restore context after regular drawing
                ctx.restore();
            }
            
            // Reset alpha
            ctx.globalAlpha = 1;
        }
        
        // Function to draw projectiles
        function drawProjectile(projectile) {
            if (projectile.fromPlayer) {
                // Player projectile (shuriken)
                ctx.fillStyle = COLORS.white;
                
                const size = projectile.width;
                const x = projectile.x;
                const y = projectile.y;
                
                // Draw shuriken with rotation
                const rotationAngle = projectile.lifetime * 15; // Rotate based on lifetime
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotationAngle);
                
                // Draw the shuriken shape
                ctx.beginPath();
                ctx.moveTo(0, -size/2);
                ctx.lineTo(size/2, 0);
                ctx.lineTo(0, size/2);
                ctx.lineTo(-size/2, 0);
                ctx.closePath();
                ctx.fill();
                
                // Center circle
                ctx.beginPath();
                ctx.arc(0, 0, size/6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            } else if (projectile.type === 'enemy_shuriken') {
                // Enemy shuriken
                ctx.fillStyle = COLORS.white;
                
                const size = projectile.width;
                const x = projectile.x;
                const y = projectile.y;
                
                // Draw with opposite rotation
                const rotationAngle = -projectile.lifetime * 15;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotationAngle);
                
                // Draw the shuriken shape
                ctx.beginPath();
                ctx.moveTo(0, -size/2);
                ctx.lineTo(size/2, 0);
                ctx.lineTo(0, size/2);
                ctx.lineTo(-size/2, 0);
                ctx.closePath();
                ctx.fill();
                
                // Center circle
                ctx.beginPath();
                ctx.arc(0, 0, size/6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            } else if (projectile.type === 'shockwave') {
                // Boss ground shockwave
                ctx.fillStyle = COLORS.white;
                ctx.fillRect(
                    projectile.x - projectile.width/2,
                    projectile.y - projectile.height/2,
                    projectile.width,
                    projectile.height
                );
                
                // Add particle trail effect
                if (Math.random() < 0.3) {
                    particles.push({
                        x: projectile.x - projectile.width/2 + Math.random() * projectile.width,
                        y: projectile.y - projectile.height/2 + Math.random() * projectile.height,
                        dx: (Math.random() - 0.5) * 20,
                        dy: -Math.random() * 30,
                        size: 2 + Math.random() * 3,
                        color: COLORS.white,
                        lifetime: 0,
                        maxLifetime: 0.3
                    });
                }
            } else if (projectile.type === 'energyBall') {
                // Boss energy projectile
                const pulseSize = Math.sin(projectile.lifetime * 5) * 2;
                
                // Outer glow
                ctx.fillStyle = COLORS.white;
                ctx.beginPath();
                ctx.arc(
                    projectile.x + projectile.width/2,
                    projectile.y + projectile.height/2,
                    projectile.width/2 + pulseSize,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Inner core
                ctx.fillStyle = COLORS.black;
                ctx.beginPath();
                ctx.arc(
                    projectile.x + projectile.width/2,
                    projectile.y + projectile.height/2,
                    projectile.width/4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        // Function to draw enemy
        function drawEnemy(enemy) {
            const flickering = Math.floor(Date.now() / 100) % 2 === 0;
            
            switch(enemy.type) {
                case 'patrol':
                    // Patrol enemy - basic ninja soldier
                    ctx.fillStyle = COLORS.white;
                    
                    // Body
                    ctx.fillRect(
                        enemy.x, 
                        enemy.y, 
                        enemy.width, 
                        enemy.height
                    );
                    
                    // Eyes
                    ctx.fillStyle = COLORS.black;
                    ctx.fillRect(
                        enemy.x + (enemy.direction > 0 ? enemy.width*2/3 : enemy.width/4), 
                        enemy.y + enemy.height/5,
                        enemy.width/8,
                        enemy.height/10
                    );
                    
                    // Legs (animated based on frame)
                    ctx.fillStyle = COLORS.black;
                    const legOffset = [0, 3, 0, -3][enemy.animFrame];
                    
                    // Left leg
                    ctx.fillRect(
                        enemy.x + enemy.width/3 - 3,
                        enemy.y + enemy.height*2/3,
                        enemy.width/6,
                        enemy.height/3 + legOffset
                    );
                    
                    // Right leg
                    ctx.fillRect(
                        enemy.x + enemy.width*2/3 - 3,
                        enemy.y + enemy.height*2/3,
                        enemy.width/6,
                        enemy.height/3 - legOffset
                    );
                    break;
                    
                case 'flyer':
                    // Flying enemy - bird/bat
                    ctx.fillStyle = COLORS.white;
                    
                    // Calculate the current position with sine wave
                    const currentY = enemy.y + enemy.yOffset;
                    
                    // Wings (animated)
                    const wingFrame = enemy.animFrame;
                    const wingExtension = [0, 5, 10, 5][wingFrame];
                    
                    // Body
                    ctx.fillRect(
                        enemy.x + enemy.width/4,
                        currentY + enemy.height/3,
                        enemy.width/2,
                        enemy.height/3
                    );
                    
                    // Wings
                    ctx.beginPath();
                    if (enemy.direction > 0) {
                        // Facing right
                        ctx.moveTo(enemy.x + enemy.width/2, currentY + enemy.height/3);
                        ctx.lineTo(enemy.x + enemy.width/2 + wingExtension, currentY);
                        ctx.lineTo(enemy.x + enemy.width, currentY + enemy.height/3);
                        ctx.lineTo(enemy.x + enemy.width/2, currentY + enemy.height/2);
                    } else {
                        // Facing left
                        ctx.moveTo(enemy.x + enemy.width/2, currentY + enemy.height/3);
                        ctx.lineTo(enemy.x + enemy.width/2 - wingExtension, currentY);
                        ctx.lineTo(enemy.x, currentY + enemy.height/3);
                        ctx.lineTo(enemy.x + enemy.width/2, currentY + enemy.height/2);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = COLORS.black;
                    ctx.fillRect(
                        enemy.x + (enemy.direction > 0 ? enemy.width*2/3 : enemy.width/4),
                        currentY + enemy.height/4,
                        enemy.width/8,
                        enemy.height/8
                    );
                    break;
                    
                case 'jumper':
                    // Jumping enemy - frog like
                    ctx.fillStyle = COLORS.white;
                    
                    // Body - crouched when on ground, stretched when jumping
                    const stretchFactor = enemy.onGround ? 0 : Math.min(1, Math.abs(enemy.dy) / 100);
                    const bodyHeight = enemy.height * (1 - stretchFactor * 0.3);
                    
                    ctx.fillRect(
                        enemy.x,
                        enemy.y + (enemy.height - bodyHeight),
                        enemy.width,
                        bodyHeight
                    );
                    
                    // Eyes
                    ctx.fillStyle = COLORS.black;
                    ctx.fillRect(
                        enemy.x + (enemy.direction > 0 ? enemy.width*2/3 : enemy.width/5),
                        enemy.y + enemy.height/5,
                        enemy.width/8,
                        enemy.height/8
                    );
                    
                    // Legs
                    if (enemy.onGround) {
                        // Crouched legs
                        ctx.fillStyle = COLORS.black;
                        ctx.fillRect(
                            enemy.x - enemy.width/4,
                            enemy.y + enemy.height - enemy.height/4,
                            enemy.width/4,
                            enemy.height/4
                        );
                        ctx.fillRect(
                            enemy.x + enemy.width,
                            enemy.y + enemy.height - enemy.height/4,
                            enemy.width/4,
                            enemy.height/4
                        );
                    } else {
                        // Extended legs when jumping
                        ctx.fillStyle = COLORS.black;
                        ctx.fillRect(
                            enemy.x - enemy.width/8,
                            enemy.y + enemy.height - enemy.height/6,
                            enemy.width/8,
                            enemy.height/6
                        );
                        ctx.fillRect(
                            enemy.x + enemy.width,
                            enemy.y + enemy.height - enemy.height/6,
                            enemy.width/8,
                            enemy.height/6
                        );
                    }
                    break;
                    
                case 'thrower':
                    // Projectile throwing enemy
                    ctx.fillStyle = COLORS.white;
                    
                    // Body
                    ctx.fillRect(
                        enemy.x, 
                        enemy.y, 
                        enemy.width, 
                        enemy.height
                    );
                    
                    // Eyes
                    ctx.fillStyle = COLORS.black;
                    ctx.fillRect(
                        enemy.x + (enemy.direction > 0 ? enemy.width*2/3 : enemy.width/4), 
                        enemy.y + enemy.height/5,
                        enemy.width/8,
                        enemy.height/10
                    );
                    
                    // Throwing arm animation
                    if (enemy.attackCooldown < 0.3) {
                        // Arm in throwing position
                        ctx.fillStyle = COLORS.black;
                        if (enemy.direction > 0) {
                            // Throwing right
                            ctx.fillRect(
                                enemy.x + enemy.width/2,
                                enemy.y + enemy.height/3,
                                enemy.width,
                                enemy.height/10
                            );
                        } else {
                            // Throwing left
                            ctx.fillRect(
                                enemy.x - enemy.width/2,
                                enemy.y + enemy.height/3,
                                enemy.width/2,
                                enemy.height/10
                            );
                        }
                    } else {
                        // Arm in normal position
                        ctx.fillStyle = COLORS.black;
                        ctx.fillRect(
                            enemy.x + (enemy.direction > 0 ? enemy.width/2 : 0),
                            enemy.y + enemy.height/3,
                            enemy.width/2,
                            enemy.height/10
                        );
                    }
                    break;
                
                case 'boss':
                    // Draw boss with damage flash effect
                    ctx.fillStyle = enemy.flashTimer > 0 && flickering ? COLORS.white : COLORS.darkGray;
                    
                    // Body
                    ctx.fillRect(
                        enemy.x, 
                        enemy.y, 
                        enemy.width, 
                        enemy.height
                    );
                    
                    // Head details
                    ctx.fillStyle = COLORS.white;
                    ctx.fillRect(
                        enemy.x + enemy.width/4, 
                        enemy.y, 
                        enemy.width/2, 
                        enemy.height/4
                    );
                    
                    // Glowing eyes
                    ctx.fillStyle = enemy.isInvulnerable ? COLORS.white : COLORS.black;
                    
                    // Left eye
                    ctx.fillRect(
                        enemy.x + enemy.width/3, 
                        enemy.y + enemy.height/10,
                        enemy.width/8,
                        enemy.height/16
                    );
                    
                    // Right eye
                    ctx.fillRect(
                        enemy.x + enemy.width*2/3 - enemy.width/8, 
                        enemy.y + enemy.height/10,
                        enemy.width/8,
                        enemy.height/16
                    );
                    
                    // Armor plates
                    ctx.fillStyle = COLORS.black;
                    
                    // Shoulder plates
                    ctx.fillRect(
                        enemy.x - enemy.width/10, 
                        enemy.y + enemy.height/4,
                        enemy.width/5,
                        enemy.height/6
                    );
                    
                    ctx.fillRect(
                        enemy.x + enemy.width - enemy.width/10, 
                        enemy.y + enemy.height/4,
                        enemy.width/5,
                        enemy.height/6
                    );
                    
                    // Arms based on attack phase
                    if (enemy.attackPhase === 2) { // Projectile phase
                        // Arms extended
                        ctx.fillRect(
                            enemy.x - enemy.width/5, 
                            enemy.y + enemy.height/3,
                            enemy.width/5,
                            enemy.height/10
                        );
                        
                        ctx.fillRect(
                            enemy.x + enemy.width, 
                            enemy.y + enemy.height/3,
                            enemy.width/5,
                            enemy.height/10
                        );
                        
                        // Energy gathering in hands
                        if (flickering) {
                            ctx.fillStyle = COLORS.white;
                            ctx.beginPath();
                            ctx.arc(
                                enemy.x - enemy.width/5, 
                                enemy.y + enemy.height/3 + enemy.height/20,
                                enemy.width/10,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                            
                            ctx.beginPath();
                            ctx.arc(
                                enemy.x + enemy.width + enemy.width/5, 
                                enemy.y + enemy.height/3 + enemy.height/20,
                                enemy.width/10,
                                0,
                                Math.PI * 2
                            );
                            ctx.fill();
                        }
                    } else {
                        // Normal arms
                        ctx.fillRect(
                            enemy.x, 
                            enemy.y + enemy.height/3,
                            enemy.width/6,
                            enemy.height/2
                        );
                        
                        ctx.fillRect(
                            enemy.x + enemy.width - enemy.width/6, 
                            enemy.y + enemy.height/3,
                            enemy.width/6,
                            enemy.height/2
                        );
                    }
                    
                    // Legs
                    ctx.fillRect(
                        enemy.x + enemy.width/4, 
                        enemy.y + enemy.height*2/3,
                        enemy.width/6,
                        enemy.height/3
                    );
                    
                    ctx.fillRect(
                        enemy.x + enemy.width - enemy.width/4 - enemy.width/6, 
                        enemy.y + enemy.height*2/3,
                        enemy.width/6,
                        enemy.height/3
                    );
                    
                    // Health bar above boss
                    ctx.fillStyle = COLORS.black;
                    ctx.fillRect(
                        enemy.x, 
                        enemy.y - 20,
                        enemy.width,
                        10
                    );
                    
                    ctx.fillStyle = COLORS.white;
                    ctx.fillRect(
                        enemy.x, 
                        enemy.y - 20,
                        (enemy.health / enemy.maxHealth) * enemy.width,
                        10
                    );
                    break;
            }
        }
        
        // Function to draw particle
        function drawParticle(particle) {
            // Set opacity based on lifetime
            ctx.globalAlpha = 1 - (particle.lifetime / particle.maxLifetime);
            
            ctx.fillStyle = particle.color;
            ctx.fillRect(particle.x - particle.size/2, particle.y - particle.size/2, particle.size, particle.size);
            
            // Update particle lifetime
            particle.lifetime += 1/60; // Assuming 60fps
            particle.x += particle.dx * 1/60;
            particle.y += particle.dy * 1/60;
            
            // Reset opacity
            ctx.globalAlpha = 1;
        }
        
        // Function to draw UI
        function drawUI() {
            // Draw player health
            const blockSize = 10;
            const blockSpacing = 12;
            const topMargin = 40;
            
            // LIFE label
            ctx.fillStyle = COLORS.white;
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('LIFE:', 10, topMargin);
            
            // Health blocks
            for (let i = 0; i < player.maxHealth; i++) {
                ctx.fillStyle = i < player.health ? COLORS.white : COLORS.darkGray;
                ctx.fillRect(60 + (i * blockSpacing), topMargin - blockSize, blockSize, blockSize);
                ctx.strokeStyle = COLORS.black;
                ctx.strokeRect(60 + (i * blockSpacing), topMargin - blockSize, blockSize, blockSize);
            }
            
            // Score
            ctx.fillStyle = COLORS.white;
            ctx.font = '16px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(`SCORE: ${player.score.toString().padStart(6, '0')}`, canvas.width - 10, 20);
        }
        
        // Function to draw Game Over screen
        function drawGameOverScreen() {
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Game Over text
            ctx.fillStyle = COLORS.white;
            ctx.font = '30px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
            
            // Score display
            ctx.font = '16px monospace';
            ctx.fillText(`FINAL SCORE: ${player.score.toString().padStart(6, '0')}`, canvas.width/2, canvas.height/2 + 20);
            
            // Continue text that blinks
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillText('PRESS SPACE TO CONTINUE', canvas.width/2, canvas.height/2 + 60);
            }
            
            // Handle restart
            if (keys[' '] || keys.Space) {
                resetGame();
                gameState = 'playing';
            }
        }
        
        // Function to draw Game Complete screen
        function drawGameCompleteScreen() {
            // Dark overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Game Complete text
            ctx.fillStyle = COLORS.white;
            ctx.font = '30px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GAME COMPLETE!', canvas.width/2, canvas.height/3);
            
            // Congratulations text
            ctx.font = '20px monospace';
            ctx.fillText('You defeated the Shadow Master!', canvas.width/2, canvas.height/2 - 20);
            
            // Score display
            ctx.font = '16px monospace';
            ctx.fillText(`FINAL SCORE: ${player.score.toString().padStart(6, '0')}`, canvas.width/2, canvas.height/2 + 20);
            
            // Continue text that blinks
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                ctx.fillText('PRESS SPACE TO PLAY AGAIN', canvas.width/2, canvas.height/2 + 60);
            }
            
            // Handle restart
            if (keys[' '] || keys.Space) {
                resetGame();
                gameState = 'playing';
            }
        }
        
        // Function to update enemies
        function updateEnemies(dt) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Animation timer for all enemies
                enemy.animTimer += dt;
                if (enemy.animTimer >= 0.2) { // Frame rate of animation
                    enemy.animFrame = (enemy.animFrame + 1) % 4; // 4 frames of animation
                    enemy.animTimer = 0;
                }
                
                // Debug boss health
                if (enemy.type === 'boss') {
                    console.log(`Boss update: health=${enemy.health}, invulnerable=${enemy.isInvulnerable}`);
                }
                
                // Enemy behavior based on type
                switch(enemy.type) {
                    case 'patrol':
                        // Basic horizontal patrol
                        enemy.x += enemy.speed * enemy.direction * dt;
                        
                        // Check for platform edges or obstacles
                        let onPlatform = false;
                        let hitWall = false;
                        
                        for (const platform of platforms) {
                            // Check if on platform
                            if (enemy.x + enemy.width > platform.x &&
                                enemy.x < platform.x + platform.width &&
                                enemy.y + enemy.height >= platform.y &&
                                enemy.y + enemy.height <= platform.y + 10) {
                                onPlatform = true;
                            }
                            
                            // Check collision with wall
                            if ((enemy.direction > 0 && 
                                 enemy.x + enemy.width + 5 >= platform.x &&
                                 enemy.x + enemy.width <= platform.x + 5 &&
                                 enemy.y + enemy.height > platform.y &&
                                 enemy.y < platform.y + platform.height) ||
                                (enemy.direction < 0 && 
                                 enemy.x - 5 <= platform.x + platform.width &&
                                 enemy.x >= platform.x + platform.width - 5 &&
                                 enemy.y + enemy.height > platform.y &&
                                 enemy.y < platform.y + platform.height)) {
                                hitWall = true;
                            }
                        }
                        
                        // Check for edge of current platform
                        const aheadX = enemy.x + enemy.width + (10 * enemy.direction);
                        const aheadY = enemy.y + enemy.height + 5;
                        let aheadOnPlatform = false;
                        
                        for (const platform of platforms) {
                            if (aheadX >= platform.x && 
                                aheadX <= platform.x + platform.width &&
                                aheadY >= platform.y &&
                                aheadY <= platform.y + 10) {
                                aheadOnPlatform = true;
                            }
                        }
                        
                        // Turn around at edges or walls
                        if (!aheadOnPlatform || hitWall) {
                            enemy.direction *= -1;
                        }
                        
                        break;
                    
                    case 'flyer':
                        // Flying enemy with sine wave pattern
                        enemy.x += enemy.speed * enemy.direction * dt;
                        
                        // Calculate y position based on sine wave
                        const time = Date.now() / 1000; // Time in seconds
                        enemy.yOffset = Math.sin(time * enemy.frequency) * enemy.amplitude;
                        
                        // Bounce off screen edges
                        if (enemy.x <= 0 || enemy.x + enemy.width >= GAME_WIDTH) {
                            enemy.direction *= -1;
                        }
                        
                        break;
                        
                    case 'jumper':
                        // Apply gravity
                        enemy.dy += GRAVITY * dt;
                        enemy.y += enemy.dy * dt;
                        
                        // Horizontal movement
                        enemy.x += enemy.speed * enemy.direction * dt;
                        
                        // Check platform collisions
                        enemy.onGround = false;
                        for (const platform of platforms) {
                            if (enemy.x + enemy.width > platform.x &&
                                enemy.x < platform.x + platform.width &&
                                enemy.y + enemy.height > platform.y &&
                                enemy.y + enemy.height < platform.y + platform.height) {
                                enemy.y = platform.y - enemy.height;
                                enemy.dy = 0;
                                enemy.onGround = true;
                            }
                        }
                        
                        // Screen boundaries
                        if (enemy.x <= 0 || enemy.x + enemy.width >= GAME_WIDTH) {
                            enemy.direction *= -1;
                        }
                        
                        // Jump logic
                        if (enemy.onGround) {
                            enemy.jumpCooldown -= dt;
                            if (enemy.jumpCooldown <= 0) {
                                enemy.dy = -enemy.jumpPower;
                                enemy.jumpCooldown = enemy.jumpInterval;
                                enemy.onGround = false;
                            }
                        }
                        
                        break;
                        
                    case 'thrower':
                        // Projectile throwing enemy
                        enemy.attackCooldown -= dt;
                        
                        // Face player
                        if (player.x < enemy.x) {
                            enemy.direction = -1;
                        } else {
                            enemy.direction = 1;
                        }
                        
                        // Attack if cooldown expired and player is in range
                        const distanceToPlayer = Math.abs(player.x - enemy.x);
                        if (enemy.attackCooldown <= 0 && distanceToPlayer < 300) {
                            // Calculate angle to player
                            const dx = player.x + player.width/2 - (enemy.x + enemy.width/2);
                            const dy = player.y + player.height/2 - (enemy.y + enemy.height/2);
                            const angle = Math.atan2(dy, dx);
                            
                            // Create projectile
                            projectiles.push({
                                x: enemy.x + enemy.width/2,
                                y: enemy.y + enemy.height/3,
                                width: 15,
                                height: 15,
                                dx: Math.cos(angle) * 150,
                                dy: Math.sin(angle) * 150,
                                damage: 1,
                                lifetime: 0,
                                type: 'enemy_shuriken',
                                fromPlayer: false
                            });
                            
                            enemy.attackCooldown = enemy.attackInterval;
                        }
                        
                        break;
                    
                    case 'boss':
                        // Update invulnerability timer
                        if (enemy.isInvulnerable) {
                            enemy.invulnerableTimer -= dt;
                            if (enemy.invulnerableTimer <= 0) {
                                enemy.isInvulnerable = false;
                            }
                        }
                        
                        // CRITICAL FIX: Boss position tracking
                        // Log every frame to catch when the boss is about to disappear
                        console.log(`Boss tracking - x:${enemy.x.toFixed(1)}, y:${enemy.y.toFixed(1)}, phase:${enemy.attackPhase}, onGround:${enemy.onGround}, dy:${enemy.dy.toFixed(1)}`);
                        
                        // SUPER AGGRESSIVE BOUNDARY ENFORCEMENT
                        // These bounds checks run EVERY FRAME regardless of phase
                        const minX = 20;
                        const maxX = GAME_WIDTH - enemy.width - 20;
                        const minY = 20;
                        const maxY = GAME_HEIGHT - enemy.height - 20;
                        
                        // Forcefully clamp the boss position within these bounds
                        if (enemy.x < minX) enemy.x = minX;
                        if (enemy.x > maxX) enemy.x = maxX;
                        if (enemy.y < minY) enemy.y = minY;
                        if (enemy.y > maxY) enemy.y = maxY;
                        
                        // Failsafe to ensure boss is always on screen
                        if (enemy.y > GAME_HEIGHT || enemy.y < 0 || enemy.x > GAME_WIDTH || enemy.x < 0) {
                            console.log("FAILSAFE: Boss was outside screen bounds! Resetting position.");
                            // If boss somehow goes off screen, force it back to a visible position
                            if (enemy.attackPhase === 2) {
                                // If in projectile phase, place at one of the corners
                                enemy.currentCorner = enemy.currentCorner || 'topLeft';
                                const cornerPos = {
                                    topLeft: {x: 50, y: 80},
                                    topRight: {x: GAME_WIDTH - enemy.width - 50, y: 80}
                                }[enemy.currentCorner];
                                enemy.x = cornerPos.x;
                                enemy.y = cornerPos.y;
                            } else {
                                // If in other phases, place at center of stage
                                enemy.x = GAME_WIDTH/2 - enemy.width/2;
                                enemy.y = GAME_HEIGHT - enemy.height - 50;
                            }
                            enemy.dy = 0; // Reset vertical momentum
                        }
                        
                        // Phase timer
                        enemy.phaseTimer -= dt;

                        if (enemy.phaseTimer <= 0) {
                            // Previous phase
                            const oldPhase = enemy.attackPhase;
                            
                            // Change to next attack phase
                            enemy.attackPhase = (enemy.attackPhase + 1) % 3;
                            enemy.phaseTimer = 4; // 4 seconds per phase
                            enemy.isInvulnerable = false;
                            
                            // Reset currentCorner when changing phases
                            if (enemy.attackPhase !== 2) {
                                enemy.currentCorner = null;
                            }
                            
                            // Create intense thunder effect for phase transition
                            screenFlash.active = true;
                            screenFlash.duration = 0.4;
                            screenFlash.intensity = 0.8;
                            
                            // Generate multiple lightning bolts for dramatic effect
                            lightning.active = true;
                            lightning.timer = 0;
                            lightning.bolts = [];
                            
                            // Create 3-5 lightning bolts
                            const numBolts = Math.floor(Math.random() * 3) + 3;
                            for (let i = 0; i < numBolts; i++) {
                                const startX = Math.random() * GAME_WIDTH;
                                
                                lightning.bolts.push({
                                    startX: startX,
                                    startY: 0,
                                    endY: GAME_HEIGHT * (0.5 + Math.random() * 0.5),
                                    width: 2 + Math.random() * 3,
                                    segmentLength: 10 + Math.random() * 20,
                                    jitter: 40 + Math.random() * 60
                                });
                            }
                            
                            console.log(`Boss phase changed: ${oldPhase} -> ${enemy.attackPhase} with thunder effect`);
                            
                            // Visual effect when entering projectile phase
                            if (enemy.attackPhase === 2) {
                                console.log("Boss entering projectile phase!");
                                // Create effect particles
                                for (let i = 0; i < 20; i++) {
                                    particles.push({
                                        x: enemy.x + enemy.width/2,
                                        y: enemy.y + enemy.height/2,
                                        dx: (Math.random() - 0.5) * 100,
                                        dy: (Math.random() - 0.5) * 100,
                                        size: 4 + Math.random() * 4,
                                        color: COLORS.white,
                                        lifetime: 0,
                                        maxLifetime: 0.8
                                    });
                                }
                            }
                        }
                        
                        // Flash timer for damage indication
                        if (enemy.flashTimer > 0) {
                            enemy.flashTimer -= dt;
                        }
                        
                        // Boss behavior based on attack phase
                        switch(enemy.attackPhase) {
                            case 0: // Ground attack phase - chase player
                                if (enemy.onGround) {
                                    // Move towards player
                                    enemy.direction = player.x < enemy.x ? -1 : 1;
                                    enemy.x += enemy.speed * enemy.direction * dt;
                                    
                                    // Occasionally release a shockwave
                                    if (Math.random() < 0.01) {
                                        // Create ground shockwaves
                                        for (let dir = -1; dir <= 1; dir += 2) {
                                            projectiles.push({
                                                x: enemy.x + enemy.width/2,
                                                y: GAME_HEIGHT - 50,
                                                width: 30,
                                                height: 10,
                                                dx: dir * 200,
                                                dy: 0,
                                                damage: 1,
                                                lifetime: 0,
                                                type: 'shockwave',
                                                fromPlayer: false
                                            });
                                        }
                                    }
                                }
                                break;
                                
                            case 1: // Jump attack phase
                                if (enemy.onGround && enemy.phaseTimer < 3.5) {
                                    // Jump towards player
                                    enemy.dy = -enemy.jumpPower;
                                    enemy.onGround = false;
                                    enemy.direction = player.x < enemy.x ? -1 : 1;
                                    
                                    // Aim jump to land near player
                                    const distanceToPlayer = player.x - enemy.x;
                                    const jumpDistance = enemy.jumpPower * 0.3; // Adjust as needed
                                    enemy.dx = Math.min(Math.max(distanceToPlayer * 0.5, -jumpDistance), jumpDistance);
                                }
                                
                                // While in air, generate falling projectiles
                                if (!enemy.onGround && Math.random() < 0.05) {
                                    projectiles.push({
                                        x: Math.random() * (GAME_WIDTH - 20),
                                        y: 0,
                                        width: 20,
                                        height: 20,
                                        dx: 0,
                                        dy: 200 + Math.random() * 100,
                                        damage: 1,
                                        lifetime: 0,
                                        type: 'energyBall',
                                        fromPlayer: false
                                    });
                                }
                                
                                // Apply gravity
                                enemy.dy += GRAVITY * dt;
                                enemy.x += enemy.dx * dt;
                                enemy.y += enemy.dy * dt;
                                
                                // Check platform collisions
                                enemy.onGround = false;
                                for (const platform of platforms) {
                                    if (enemy.x + enemy.width > platform.x &&
                                        enemy.x < platform.x + platform.width &&
                                        enemy.y + enemy.height > platform.y &&
                                        enemy.y + enemy.height < platform.y + platform.height) {
                                        enemy.y = platform.y - enemy.height;
                                        enemy.dy = 0;
                                        enemy.onGround = true;
                                        
                                        // Create landing shockwave
                                        if (enemy.dy > 200) {
                                            for (let dir = -1; dir <= 1; dir += 1) {
                                                projectiles.push({
                                                    x: enemy.x + enemy.width/2,
                                                    y: enemy.y + enemy.height - 10,
                                                    width: 40,
                                                    height: 10,
                                                    dx: dir * 150,
                                                    dy: 0,
                                                    damage: 1,
                                                    lifetime: 0,
                                                    type: 'shockwave',
                                                    fromPlayer: false
                                                });
                                            }
                                        }
                                    }
                                }
                                
                                // Screen boundaries
                                if (enemy.x < 0) enemy.x = 0;
                                if (enemy.x + enemy.width > GAME_WIDTH) enemy.x = GAME_WIDTH - enemy.width;
                                if (enemy.y + enemy.height > GAME_HEIGHT) {
                                    enemy.y = GAME_HEIGHT - enemy.height;
                                    enemy.dy = 0;
                                    enemy.onGround = true;
                                }
                                break;
                                
                            case 2: // Projectile barrage phase
                                // Make boss fly to a corner and fire projectiles in patterns
                                enemy.onGround = false; // Boss is always in the air during this phase
                                
                                // COMPLETE POSITION OVERRIDE SYSTEM FOR PROJECTILE PHASE
                                // This completely takes over position control during this phase
                                
                                // Initialize corner position if not set
                                if (!enemy.currentCorner) {
                                    enemy.currentCorner = Math.random() < 0.5 ? 'topLeft' : 'topRight';
                                    console.log("Boss initialized corner:", enemy.currentCorner);
                                }
                                
                                // Define corner positions with VERY conservative bounds
                                const cornerPositions = {
                                    topLeft: {x: 80, y: 100},
                                    topRight: {x: GAME_WIDTH - enemy.width - 80, y: 100}
                                };
                                
                                // Target position based on current corner
                                const targetX = cornerPositions[enemy.currentCorner].x;
                                const targetY = cornerPositions[enemy.currentCorner].y;
                                
                                // Calculate distance to target
                                const dx = targetX - enemy.x;
                                const dy = targetY - enemy.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                // Move towards the target corner
                                const moveSpeed = 150;
                                
                                if (distance > 5) {
                                    // Normal movement when far from target
                                    enemy.x += (dx / distance) * moveSpeed * dt;
                                    enemy.y += (dy / distance) * moveSpeed * dt;
                                } else {
                                    // When at target, make small hovering movements
                                    enemy.x = targetX + Math.sin(Date.now() / 500) * 5;
                                    enemy.y = targetY + Math.sin(Date.now() / 700) * 5;
                                }
                                
                                // CRITICAL: Cancel ALL physics effects
                                enemy.dy = 0;
                                enemy.dx = 0;
                                
                                // Switch corners less frequently (only 0.5% chance per frame)
                                if (Math.random() < 0.005 * dt) {
                                    enemy.currentCorner = enemy.currentCorner === 'topLeft' ? 'topRight' : 'topLeft';
                                    console.log("Boss switched corner to:", enemy.currentCorner);
                                }
                                
                                // Fire projectiles in patterns
                                if (enemy.phaseTimer < 3.8 && enemy.phaseTimer % 0.5 < 0.05) {
                                    // Fire projectiles in a pattern
                                    const projectileCount = 5; // Number of projectiles in the barrage
                                    
                                    // Create spiral pattern
                                    for (let i = 0; i < projectileCount; i++) {
                                        const angle = (i / projectileCount) * Math.PI * 2 + enemy.phaseTimer;
                                        projectiles.push({
                                            x: enemy.x + enemy.width/2,
                                            y: enemy.y + enemy.height/2,
                                            width: 15,
                                            height: 15,
                                            dx: Math.cos(angle) * 150,
                                            dy: Math.sin(angle) * 150,
                                            damage: 1,
                                            lifetime: 0,
                                            type: 'energyBall',
                                            fromPlayer: false
                                        });
                                    }
                                }
                                
                                // Boss is vulnerable during this phase
                                enemy.isInvulnerable = false;
                                
                                // Very strict screen boundaries check to ensure boss doesn't go off-screen
                                if (enemy.x < 20) {
                                    enemy.x = 20;
                                    console.log("Boss hit left boundary");
                                }
                                if (enemy.x + enemy.width > GAME_WIDTH - 20) {
                                    enemy.x = GAME_WIDTH - enemy.width - 20;
                                    console.log("Boss hit right boundary");
                                }
                                if (enemy.y < 20) {
                                    enemy.y = 20;
                                    console.log("Boss hit top boundary");
                                }
                                if (enemy.y > GAME_HEIGHT / 3) {
                                    enemy.y = GAME_HEIGHT / 3;
                                    console.log("Boss hit bottom boundary");
                                }
                                
                                // Double-check that corner is still set
                                if (!enemy.currentCorner) {
                                    console.log("Boss lost corner tracking! Resetting to topLeft");
                                    enemy.currentCorner = 'topLeft';
                                }
                                
                                // Log boss position to debug disappearance issue
                                console.log(`Boss position: x=${enemy.x.toFixed(1)}, y=${enemy.y.toFixed(1)}, corner=${enemy.currentCorner}`);
                                
                                break;
                        }
                        break;
                }
                
                // Check if enemy is dead
                if (enemy.health <= 0) {
                    // Log boss death
                    if (enemy.type === 'boss') {
                        console.log("Boss is being removed, health is now zero");
                    }
                    
                    // Add death animation/particles
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    
                    // Add score
                    if (enemy.type === 'boss') {
                        console.log("Boss defeated! Health was:", enemy.health);
                        // Boss death - big explosion and high score
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                createExplosion(
                                    enemy.x + Math.random() * enemy.width,
                                    enemy.y + Math.random() * enemy.height
                                );
                            }, i * 200);
                        }
                        player.score += 5000;
                        
                        // Clear all projectiles immediately
                        projectiles = [];
                        
                        // Player completed the game - immediate transition to game complete
                        gameState = 'game_complete';
                        
                        // Remove enemy immediately
                        enemies.splice(i, 1);
                        return; // Exit the loop to prevent further processing
                    } else {
                        player.score += 100;
                        
                        // Remove regular enemy
                        enemies.splice(i, 1);
                    }
                }
            }
        }
        
        // Function to create explosion particles
        function createExplosion(x, y) {
            // Create particles
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 50;
                particles.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 4,
                    color: COLORS.white,
                    lifetime: 0,
                    maxLifetime: 0.5 + Math.random() * 0.5
                });
            }
        }
        
        // Function to check collisions
        function checkCollisions() {
            // Player projectiles against enemies
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                // Only check player projectiles
                if (proj.fromPlayer) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        
                        // Simple collision detection
                        if (proj.x < enemy.x + enemy.width &&
                            proj.x + proj.width > enemy.x &&
                            proj.y < enemy.y + enemy.height &&
                            proj.y + proj.height > enemy.y) {
                            
                            // Special handling for boss - check invulnerability
                            if (enemy.type === 'boss' && enemy.isInvulnerable) {
                                console.log("Boss deflected a projectile (invulnerable)");
                                // Boss is invulnerable - create deflect effect
                                for (let k = 0; k < 3; k++) {
                                    particles.push({
                                        x: proj.x,
                                        y: proj.y,
                                        dx: -proj.dx * 0.5 + (Math.random() - 0.5) * 20,
                                        dy: (Math.random() - 0.5) * 20,
                                        size: 2 + Math.random() * 2,
                                        color: COLORS.white,
                                        lifetime: 0,
                                        maxLifetime: 0.2
                                    });
                                }
                                // Remove projectile
                                projectiles.splice(i, 1);
                                break;
                            }
                            
                            // Damage enemy if not an invulnerable boss
                            if (enemy.type === 'boss') {
                                console.log("Boss hit by projectile before damage:", enemy.health);
                            }
                            
                            // Only damage if it's not a boss that's invulnerable
                            if (!(enemy.type === 'boss' && enemy.isInvulnerable)) {
                                // Only damage enemies with positive health
                                if (enemy.health > 0) {
                                    enemy.health--;
                                    
                                    // Set boss invulnerability and flash effect
                                    if (enemy.type === 'boss') {
                                        console.log("Boss hit! Health remaining:", enemy.health);
                                        enemy.isInvulnerable = true;
                                        enemy.invulnerableTimer = 0.5;
                                        enemy.flashTimer = 0.5;
                                        
                                        // If boss is in projectile phase (phase 2), force return to ground attacks
                                        if (enemy.attackPhase === 2) {
                                            console.log("Boss hit during projectile phase! Returning to ground attacks.");
                                            enemy.attackPhase = 0; // Return to ground attacks (phase 0)
                                            enemy.phaseTimer = 4; // Reset phase timer
                                            enemy.onGround = false; // Will fall back down
                                            enemy.dy = 100; // Slight downward momentum
                                            enemy.currentCorner = null; // Reset corner selection
                                        }
                                    }
                                }
                            }
                            
                            // Create small hit effect
                            for (let k = 0; k < 5; k++) {
                                particles.push({
                                    x: proj.x,
                                    y: proj.y,
                                    dx: (Math.random() - 0.5) * 30,
                                    dy: (Math.random() - 0.5) * 30,
                                    size: 2 + Math.random() * 3,
                                    color: COLORS.white,
                                    lifetime: 0,
                                    maxLifetime: 0.3
                                });
                            }
                            
                            // Remove projectile
                            projectiles.splice(i, 1);
                            break;
                        }
                    }
                } else {
                    // Enemy projectiles against player
                    if (proj.x < player.x + player.width &&
                        proj.x + proj.width > player.x &&
                        proj.y < player.y + player.height &&
                        proj.y + proj.height > player.y &&
                        player.invulnerable <= 0) {
                        
                        // Damage player
                        player.health--;
                        player.invulnerable = 1.5; // 1.5 second invulnerability
                        
                        // Knockback effect
                        const knockbackDir = player.x < enemy.x ? -1 : 1;
                        player.dx = knockbackDir * 150;
                        player.dy = -200;
                        
                        // Create hit effect
                        for (let k = 0; k < 10; k++) {
                            particles.push({
                                x: player.x + player.width/2,
                                y: player.y + player.height/2,
                                dx: (Math.random() - 0.5) * 50,
                                dy: (Math.random() - 0.5) * 50 - 20,
                                size: 2 + Math.random() * 3,
                                color: COLORS.white,
                                lifetime: 0,
                                maxLifetime: 0.5
                            });
                        }
                        
                        break;
                    }
                }
            }
            
            // Player collision with enemies
            if (player.invulnerable <= 0) {
                for (const enemy of enemies) {
                    if (player.x < enemy.x + enemy.width &&
                        player.x + player.width > enemy.x &&
                        player.y < enemy.y + enemy.height &&
                        player.y + player.height > enemy.y) {
                        
                        // Special handling for boss
                        if (enemy.type === 'boss') {
                            console.log("Player collided with boss");
                            // Player jumped on boss head - damage boss instead
                            if (player.dy > 0 && player.y + player.height < enemy.y + enemy.height/2) {
                                console.log("Player jumped on boss head, invulnerable:", enemy.isInvulnerable);
                                
                                // Only damage the boss if it's not currently invulnerable
                                if (!enemy.isInvulnerable && enemy.health > 0) {
                                    console.log("Damaging boss from head jump");
                                    enemy.health--;
                                    console.log("Boss head hit! Health remaining:", enemy.health);
                                    
                                    // Set boss flash effect
                                    enemy.isInvulnerable = true;
                                    enemy.invulnerableTimer = 0.5;
                                    enemy.flashTimer = 0.5;
                                    
                                    // Create hit effect
                                    for (let k = 0; k < 10; k++) {
                                        particles.push({
                                            x: enemy.x + Math.random() * enemy.width,
                                            y: enemy.y + Math.random() * enemy.height,
                                            dx: (Math.random() - 0.5) * 50,
                                            dy: (Math.random() - 0.5) * 50,
                                            size: 2 + Math.random() * 3,
                                            color: COLORS.white,
                                            lifetime: 0,
                                            maxLifetime: 0.5
                                        });
                                    }
                                } else {
                                    console.log("Boss blocked head jump (invulnerable)");
                                }
                                
                                // Set the player to jump off the boss
                                player.dy = -350;
                                continue; // Skip the rest of damage code
                            }
                        }
                        
                        // Damage player
                        player.health--;
                        player.invulnerable = 1.5; // 1.5 second invulnerability
                        
                        break;
                    }
                }
            }
        }
    </script>
</body>
</html>